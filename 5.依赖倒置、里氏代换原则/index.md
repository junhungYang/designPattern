# 依赖倒置原则
依赖倒置原则的解释是**抽象不应该依赖细节，系接应该依赖于抽象**，说白了就是要**针对接口编程，不要对实现编程**

在一台电脑的硬件中，主板、CPU、内存、硬盘都是在针对接口设计的，所以说当我们希望拓展电脑的某些配置时，我们只需要对应购买相同接口的硬件即可，同样当某些硬件出现问题时，例如有两条内存，其中一条出现问题，我们把出现问题的那一条拔下来也不会影响电脑的正常启动。相反假如硬件是针对实现来设计的话，内存就要对应到具体的某个品牌的主板，或者更糟糕的情况是主板跟内存是焊接在一起的甚至就是一个整体，那就会出现想要换一个内存却要把主板也换掉的尴尬

依赖倒转原则
1. **高层模块不应该依赖低层模块。两个都应该依赖抽象**
2. **抽象不应该依赖细节，细节应该依赖抽象**

依赖倒置原则其实是面向对象设计的标志，如果编写程序时考虑的都是如何针对抽象编程而不是针对细节编程，即**程序中的所有依赖都终止于抽象类或者接口**，那就是面向对象的设计。


# 里氏代换原则
**一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的差别，也就是说，在软件里面，把父类替换成它的子类，程序的行为没有变化。简单低说 子类必须能够替换掉它们的父类型**

在鸟的实际归类中企鹅可以分类为鸟类，但是在面向对象设计时不可以，原因是子类拥有父类所有非private的行为和属性，鸟为飞，企鹅是鸟类，所以企鹅可以继承鸟，那么企鹅也会飞，但实际情况是企鹅飞不了，所以企鹅不能继承鸟类。

在这里 假如企鹅继承鸟 把父类替换成子类后，子类会出错，因为子类变得会飞了，而把子类替换成父类也不行，因为父类变得不会飞了，这就违背了里氏代换原则。

**只有当子类可以替换掉父类。软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。**

**由于有了里氏代换原则，才使得开放-封闭称为了可能，由于子类型的可替换性，才使得使用父类类型的模块在无需修改的情况下就可以拓展。**假如某一模块原来使用的是父类对象，某一天因为需要拓展部分功能，因此喔们基于这写新功能创建了一个子类，将这个子类给该模块使用，此时该模块基于原来的父类所设置的属性或方法依然可以使用，并且也能使用新的功能了，这就是因为在我们设计父类与子类时遵循了里氏代换原则。





