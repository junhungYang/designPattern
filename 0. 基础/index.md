# 类与实例
类就是具有相同的属性和功能的对象的抽象集合

实例就是一个真实的对象。比如我们都是“人”，而我们其实就是“人”类的实例。实例化就是创建对象的过程

# 属性与修饰符

属性是一个方法或一对方法（geetter和setter），但在调用它的代码看来，它是一个字段，即属性适合于以字段的方式使用方法调用的场合。
```typescript
class A {
  _name:string = ''

  public sex:string = 'male'
  private age:number = 18

  get name() {
    return this._name
  }
  set name(value) {
    this._name = value
  }
}
```

**public** 表示它所修饰的类成员可以允许其他任何类来访问，俗称公有的。 

**private** 表示只允许同一个类中的成员访问，其他类包括它的子类无法访问，俗称私有的

**protected** 表示继承时子类可以对基类有完全的访问权，也就是说，protected修饰的类成员，对子类公开，但不对其他类公开

属性有两个方法 get和set。get访问器返回与声明的属性相同的数据类型，表示的意思是调用时可以得到内部字段的值或引用; set访问器没有显示设置参数，但它有一个音是参数，用关键字value表示，它的作用是调用 属性时 可以给内部的字段或引用赋值

**get,set访问器与public的区别**，这里可能会产生疑问，比起使用访问器，直接使用public属性符不是更方便吗? public与访问器的差别在于，public 并不能对外界的访问产生控制，而访问器可以设置一些条件用于限制外界的访问。**这就像我们的房子，我们并不希望它是全透明的（public），而我们也不希望他是全封闭的(private)，更多时候我们希望它有不透明的墙和适当的窗户（访问器），过滤掉外界无益的东西，而只是让有益的阳光或者凉爽的风能进来。**

# 封装
封装是面向对象的三大特性之一。**每个对象都包含它能进行操作所需要的所有信息，这个特性称为封装**，因此对象不必因爱其他对象来玩长城自己的操作。

> 封装的好处
1. 良好的封装能够减少耦合
2. 类内部的实现可以自由的修改
3. 类就具有清晰的对外接口 

# 继承 
**对象的继承代表了一种‘is-a’的关系**，如果两个对象A和B，可以描述为‘B是A’，则可以表明B可以继承A。‘猫是哺乳动物’，就说明了猫与哺乳动物之间继承与被继承的关系。实际上**继承者还可以理解为是对被继承者的特殊化，因为它除了具备被继承者的特性外，还具备自己独有的个性**。

继承定义了类如何相互关联，共享特性。继承的工作方式是，定义父类和子类，或叫做基类和派生类，其中子类继承父类的所有特性。子类不但继承了父类的所有特性，还可以定义新的特性

> 如果子类继承于父类
> 1. 子类拥有父类非private属性（public、protected）和功能
> 2. 子类具有自己的属性和功能，即子类可以拓展父类没有的属性和功能
> 3. 子类还可以以自己的方式实现父类的功能（方法重写） 

子类从它的父类中继承的成员有**方法、域、属性、事件、索引指示器**，但对于构造方法（constructor）它不能被继承，只能被调用。

**继承的优点**，不用继承的话，如果要修改功能，就必须在所有重复的方法中修改，代码越多，出错的可能就越大，而继承的优点是，继承使得所有子类公共的部分都放在了父类，使得代码得到了共享，这就避免了重复，另外，继承可使得修改或拓展继承而来的实现较为容易。

**继承的缺点**，继承是有缺点的，那就是父类变，则子类不得不变。另外继承会破坏包装 ，父类实现细节暴露给子类。继承显然是一种类与类之间强耦合的关系。

当两个类之间具备‘is-a’的关系时，就可以考虑用继承了，因为这表示一个类是另一个类的特殊种类，而当两个类之间是‘has-a’的关系时，表示某个角色具有某一项责任，此时不合适用继承，比如飞机场有飞机，但非继不能去继承飞机场。

# 多态
多态是面向对象的第三大特性，多态表示不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行

**多态特征**
> 1. 子类以父类身份出现
> 2. 子类在工作时以自己的方式来实现
> 3. 子类以父类的身份出现时，子类特有的属性和方法不可以使用。

为了使子类的实例完全接替来自父类的类成员，父类必须将该成员声明为虚拟的。然后子类可以将父类实现替换为它自己的实现，这就是方法重写。

由于Cat和Dog都有shout的方法，只是叫的声音不同，所以我们可以让Animal有一个Shout的虚拟方法，然后让Cat和Dog去重写这个Shout，用的时候，就可以用猫或狗代替Animal叫唤，来达到多态的目的

多态的原理是当方法被调用时，无论对象是否被转换为其父类，都只有位于对象继承链最末端的方法实现会被调用。也就是说，虚方法是按照其运行时类型而非编译时类型进行动态绑定调用的。

# 抽象类

**特征**
1. 抽象类不能实例化
2. 抽象方法是必须被子类重写的方法
3. 如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否包含其他一般方法

让抽象类拥有尽可能多的共同代码，拥有尽可能少的数据。

抽象类通常代表一个抽象概念，它提供一个继承的出发点，当设计一个新的抽象类时，一定是用来继承的，所以，在一个以继承关系形成的等级结构里面，树叶树叶结点应该是具体类，而树枝节点均应当是抽象类。

# 接口
接口是把隐式公共方法和属性组合起来。以**封装特定功能**的一个集合。一旦类实现了接口，类就可以支持接口所指定的所有属性和成员。一个类可以支持多个接口，多个类也可以支持相同的接口，接口的命名前面要加一个大写字母‘I’

**抽象类与接口的差别**

抽象类可以给出一些成员的实现，接口却不好含成员的实现，抽象类的抽象成员可被子类部分实现(即有些可以直接继承)，接口的成员需要实现类完全实现(类不具备将接口成员继承的可能性)，一个类只能继承一个抽象类，但可实现多个接口。

1. 类是对对象的抽象；抽象类是对类的抽象；**接口是对行为的抽象**
2. 如果行为跨越不同类的对象，可使用接口；对于一些相似的类对象，用继承抽象类。
3. 从设计角度讲，抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类，而接口是根本不知子类的存在，方法如何实现还不确认，预先定义。抽象类是自底而上抽象出来，而接口是自顶向下设计的。

**实现接口和继承抽象类并不冲突**，可以让超人继承认类，再实现飞行接口。